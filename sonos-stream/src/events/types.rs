//! Event types for the sonos-stream crate
//!
//! This module defines all event types used in the streaming system, including
//! both regular change events (deltas) and special resync events (full state).

use std::net::IpAddr;
use std::time::{Duration, SystemTime};
use serde::{Deserialize, Serialize};

use crate::registry::RegistrationId;

/// An enriched event that includes context and source information
#[derive(Debug, Clone)]
pub struct EnrichedEvent {
    /// Registration ID this event belongs to
    pub registration_id: RegistrationId,

    /// IP address of the speaker that generated this event
    pub speaker_ip: IpAddr,

    /// UPnP service that generated this event
    pub service: sonos_api::Service,

    /// Source of this event (UPnP notification, polling, or resync)
    pub event_source: EventSource,

    /// Timestamp when this event was processed
    pub timestamp: SystemTime,

    /// The actual event data
    pub event_data: EventData,
}

impl EnrichedEvent {
    /// Create a new enriched event
    pub fn new(
        registration_id: RegistrationId,
        speaker_ip: IpAddr,
        service: sonos_api::Service,
        event_source: EventSource,
        event_data: EventData,
    ) -> Self {
        Self {
            registration_id,
            speaker_ip,
            service,
            event_source,
            timestamp: SystemTime::now(),
            event_data,
        }
    }

    /// Check if this is a resync event
    pub fn is_resync_event(&self) -> bool {
        matches!(self.event_data, EventData::AVTransportResync(_) | EventData::RenderingControlResync(_))
    }

    /// Get the resync reason if this is a resync event
    pub fn resync_reason(&self) -> Option<ResyncReason> {
        match &self.event_source {
            EventSource::ResyncDetection { reason } => Some(reason.clone()),
            _ => None,
        }
    }
}

/// Source of an event - indicates whether it came from UPnP events, polling, or resync detection
#[derive(Debug, Clone)]
pub enum EventSource {
    /// Event came from a UPnP NOTIFY message
    UPnPNotification {
        /// UPnP subscription ID
        subscription_id: String
    },

    /// Event was generated by polling device state
    PollingDetection {
        /// Current polling interval
        poll_interval: Duration
    },

    /// Event was generated by resync detection due to state drift
    ResyncDetection {
        /// Reason for the resync
        reason: ResyncReason
    },
}

/// Reason why a resync event was generated
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ResyncReason {
    /// No events were received for too long
    EventTimeoutDetected,

    /// Polling found different state than expected
    PollingDiscrepancy,

    /// Subscription was renewed, state may have drifted
    SubscriptionRenewal,

    /// Firewall blocking was detected proactively
    FirewallBlocked,

    /// Network connectivity issues detected
    NetworkIssues,

    /// Initial state query (first time registering)
    InitialState,

    /// Manual resync requested (future feature)
    ExplicitRefresh,
}

impl std::fmt::Display for ResyncReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ResyncReason::EventTimeoutDetected => write!(f, "event timeout detected"),
            ResyncReason::PollingDiscrepancy => write!(f, "polling discrepancy"),
            ResyncReason::SubscriptionRenewal => write!(f, "subscription renewal"),
            ResyncReason::FirewallBlocked => write!(f, "firewall blocked"),
            ResyncReason::NetworkIssues => write!(f, "network issues"),
            ResyncReason::InitialState => write!(f, "initial state"),
            ResyncReason::ExplicitRefresh => write!(f, "explicit refresh"),
        }
    }
}

/// Event data - either change events (deltas) or resync events (full state)
#[derive(Debug, Clone)]
pub enum EventData {
    // Regular change events (delta only)
    /// AVTransport service change event
    AVTransportChange(AVTransportDelta),

    /// RenderingControl service change event
    RenderingControlChange(RenderingControlDelta),

    /// DeviceProperties service change event
    DevicePropertiesChange(DevicePropertiesDelta),

    // Special resync events (full state) when drift detected
    /// AVTransport service resync event with full state
    AVTransportResync(AVTransportFullState),

    /// RenderingControl service resync event with full state
    RenderingControlResync(RenderingControlFullState),

    /// DeviceProperties service resync event with full state
    DevicePropertiesResync(DevicePropertiesFullState),
}

impl EventData {
    /// Get the service type for this event data
    pub fn service_type(&self) -> sonos_api::Service {
        match self {
            EventData::AVTransportChange(_) | EventData::AVTransportResync(_) => {
                sonos_api::Service::AVTransport
            }
            EventData::RenderingControlChange(_) | EventData::RenderingControlResync(_) => {
                sonos_api::Service::RenderingControl
            }
            EventData::DevicePropertiesChange(_) | EventData::DevicePropertiesResync(_) => {
                // DeviceProperties service doesn't exist in sonos-api, using ZoneGroupTopology as fallback
                sonos_api::Service::ZoneGroupTopology
            }
        }
    }

    /// Check if this is a change event (delta)
    pub fn is_change_event(&self) -> bool {
        matches!(
            self,
            EventData::AVTransportChange(_)
            | EventData::RenderingControlChange(_)
            | EventData::DevicePropertiesChange(_)
        )
    }

    /// Check if this is a resync event (full state)
    pub fn is_resync_event(&self) -> bool {
        matches!(
            self,
            EventData::AVTransportResync(_)
            | EventData::RenderingControlResync(_)
            | EventData::DevicePropertiesResync(_)
        )
    }
}

// AVTransport event types

/// Delta change for AVTransport service
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AVTransportDelta {
    /// Transport state change (if it changed)
    pub transport_state: Option<String>,

    /// Current track URI change (if it changed)
    pub current_track_uri: Option<String>,

    /// Track duration change (if it changed)
    pub track_duration: Option<String>,

    /// Relative time position change (if it changed)
    pub rel_time: Option<String>,

    /// Play mode change (if it changed)
    pub play_mode: Option<String>,

    /// Current track metadata change (if it changed)
    pub track_metadata: Option<String>,
}

/// Full state for AVTransport service (used in resync events)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AVTransportFullState {
    /// Current transport state
    pub transport_state: String,

    /// Current track URI
    pub current_track_uri: Option<String>,

    /// Track duration
    pub track_duration: Option<String>,

    /// Relative time position
    pub rel_time: Option<String>,

    /// Current play mode
    pub play_mode: Option<String>,

    /// Current track metadata
    pub track_metadata: Option<String>,

    /// Queue size/length
    pub queue_length: Option<u32>,

    /// Current track number in queue
    pub track_number: Option<u32>,
}

// RenderingControl event types

/// Delta change for RenderingControl service
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RenderingControlDelta {
    /// Volume level change (if it changed)
    pub volume: Option<u16>,

    /// Mute state change (if it changed)
    pub mute: Option<bool>,

    /// Bass level change (if it changed)
    pub bass: Option<i8>,

    /// Treble level change (if it changed)
    pub treble: Option<i8>,

    /// Loudness setting change (if it changed)
    pub loudness: Option<bool>,
}

/// Full state for RenderingControl service (used in resync events)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RenderingControlFullState {
    /// Current volume level (0-100)
    pub volume: String, // Using String to match the pattern in event_detector

    /// Current mute state
    pub mute: Option<bool>,

    /// Current bass level
    pub bass: Option<i8>,

    /// Current treble level
    pub treble: Option<i8>,

    /// Current loudness setting
    pub loudness: Option<bool>,

    /// Balance setting (-100 to +100)
    pub balance: Option<i8>,
}

// DeviceProperties event types

/// Delta change for DeviceProperties service
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DevicePropertiesDelta {
    /// Zone name change (if it changed)
    pub zone_name: Option<String>,

    /// Zone icon change (if it changed)
    pub zone_icon: Option<String>,

    /// Configuration information change (if it changed)
    pub configuration: Option<String>,
}

/// Full state for DeviceProperties service (used in resync events)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DevicePropertiesFullState {
    /// Current zone name
    pub zone_name: Option<String>,

    /// Current zone icon
    pub zone_icon: Option<String>,

    /// Current configuration information
    pub configuration: Option<String>,

    /// Device capabilities
    pub capabilities: Option<String>,

    /// Firmware version
    pub firmware_version: Option<String>,
}

/// A resync event with additional context
#[derive(Debug, Clone)]
pub struct ResyncEvent {
    /// Reason for the resync
    pub reason: ResyncReason,

    /// Complete current state
    pub full_state: EventData,

    /// Previous state (if known)
    pub previous_state: Option<EventData>,

    /// Time when resync was detected
    pub detected_at: SystemTime,
}

impl ResyncEvent {
    /// Create a new resync event
    pub fn new(reason: ResyncReason, full_state: EventData) -> Self {
        Self {
            reason,
            full_state,
            previous_state: None,
            detected_at: SystemTime::now(),
        }
    }

    /// Create a resync event with previous state context
    pub fn with_previous_state(
        reason: ResyncReason,
        full_state: EventData,
        previous_state: EventData,
    ) -> Self {
        Self {
            reason,
            full_state,
            previous_state: Some(previous_state),
            detected_at: SystemTime::now(),
        }
    }
}

/// Utility functions for working with event data
impl AVTransportDelta {
    /// Check if this delta contains any changes
    pub fn has_changes(&self) -> bool {
        self.transport_state.is_some()
            || self.current_track_uri.is_some()
            || self.track_duration.is_some()
            || self.rel_time.is_some()
            || self.play_mode.is_some()
            || self.track_metadata.is_some()
    }

    /// Create a delta with only transport state change
    pub fn transport_state_change(new_state: String) -> Self {
        Self {
            transport_state: Some(new_state),
            current_track_uri: None,
            track_duration: None,
            rel_time: None,
            play_mode: None,
            track_metadata: None,
        }
    }

    /// Create a delta with only track change
    pub fn track_change(track_uri: String, track_metadata: Option<String>) -> Self {
        Self {
            transport_state: None,
            current_track_uri: Some(track_uri),
            track_duration: None,
            rel_time: None,
            play_mode: None,
            track_metadata,
        }
    }
}

impl RenderingControlDelta {
    /// Check if this delta contains any changes
    pub fn has_changes(&self) -> bool {
        self.volume.is_some()
            || self.mute.is_some()
            || self.bass.is_some()
            || self.treble.is_some()
            || self.loudness.is_some()
    }

    /// Create a delta with only volume change
    pub fn volume_change(new_volume: u16) -> Self {
        Self {
            volume: Some(new_volume),
            mute: None,
            bass: None,
            treble: None,
            loudness: None,
        }
    }

    /// Create a delta with only mute change
    pub fn mute_change(muted: bool) -> Self {
        Self {
            volume: None,
            mute: Some(muted),
            bass: None,
            treble: None,
            loudness: None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_enriched_event_creation() {
        let reg_id = RegistrationId::new(1);
        let ip: IpAddr = "192.168.1.100".parse().unwrap();
        let service = sonos_api::Service::AVTransport;
        let source = EventSource::UPnPNotification {
            subscription_id: "uuid:123".to_string(),
        };
        let data = EventData::AVTransportChange(AVTransportDelta::transport_state_change(
            "PLAYING".to_string(),
        ));

        let event = EnrichedEvent::new(reg_id, ip, service, source, data);

        assert_eq!(event.registration_id, reg_id);
        assert_eq!(event.speaker_ip, ip);
        assert_eq!(event.service, service);
        assert!(!event.is_resync_event());
        assert!(event.resync_reason().is_none());
    }

    #[test]
    fn test_resync_event() {
        let reg_id = RegistrationId::new(1);
        let ip: IpAddr = "192.168.1.100".parse().unwrap();
        let service = sonos_api::Service::AVTransport;
        let source = EventSource::ResyncDetection {
            reason: ResyncReason::FirewallBlocked,
        };
        let data = EventData::AVTransportResync(AVTransportFullState {
            transport_state: "PLAYING".to_string(),
            current_track_uri: None,
            track_duration: None,
            rel_time: None,
            play_mode: None,
            track_metadata: None,
            queue_length: None,
            track_number: None,
        });

        let event = EnrichedEvent::new(reg_id, ip, service, source, data);

        assert!(event.is_resync_event());
        assert_eq!(event.resync_reason(), Some(ResyncReason::FirewallBlocked));
    }

    #[test]
    fn test_event_data_service_type() {
        let av_change = EventData::AVTransportChange(AVTransportDelta::transport_state_change(
            "PLAYING".to_string(),
        ));
        assert_eq!(av_change.service_type(), sonos_api::Service::AVTransport);
        assert!(av_change.is_change_event());
        assert!(!av_change.is_resync_event());

        let rc_resync = EventData::RenderingControlResync(RenderingControlFullState {
            volume: "50".to_string(),
            mute: Some(false),
            bass: None,
            treble: None,
            loudness: None,
            balance: None,
        });
        assert_eq!(rc_resync.service_type(), sonos_api::Service::RenderingControl);
        assert!(!rc_resync.is_change_event());
        assert!(rc_resync.is_resync_event());
    }

    #[test]
    fn test_delta_has_changes() {
        let empty_delta = AVTransportDelta {
            transport_state: None,
            current_track_uri: None,
            track_duration: None,
            rel_time: None,
            play_mode: None,
            track_metadata: None,
        };
        assert!(!empty_delta.has_changes());

        let change_delta = AVTransportDelta::transport_state_change("PAUSED".to_string());
        assert!(change_delta.has_changes());

        let rc_delta = RenderingControlDelta::volume_change(75);
        assert!(rc_delta.has_changes());
    }

    #[test]
    fn test_resync_reason_display() {
        assert_eq!(ResyncReason::FirewallBlocked.to_string(), "firewall blocked");
        assert_eq!(ResyncReason::EventTimeoutDetected.to_string(), "event timeout detected");
        assert_eq!(ResyncReason::PollingDiscrepancy.to_string(), "polling discrepancy");
    }

    #[test]
    fn test_resync_event_creation() {
        let full_state = EventData::AVTransportResync(AVTransportFullState {
            transport_state: "PLAYING".to_string(),
            current_track_uri: None,
            track_duration: None,
            rel_time: None,
            play_mode: None,
            track_metadata: None,
            queue_length: None,
            track_number: None,
        });

        let resync_event = ResyncEvent::new(ResyncReason::NetworkIssues, full_state);
        assert_eq!(resync_event.reason, ResyncReason::NetworkIssues);
        assert!(resync_event.previous_state.is_none());
    }
}