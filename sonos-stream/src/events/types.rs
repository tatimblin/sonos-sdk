//! Event types for the sonos-stream crate
//!
//! This module defines all event types used in the streaming system, including
//! both regular change events (deltas) and special resync events (full state).

use std::net::IpAddr;
use std::time::{Duration, SystemTime};
use serde::{Deserialize, Serialize};

use crate::registry::RegistrationId;

/// An enriched event that includes context and source information
#[derive(Debug, Clone)]
pub struct EnrichedEvent {
    /// Registration ID this event belongs to
    pub registration_id: RegistrationId,

    /// IP address of the speaker that generated this event
    pub speaker_ip: IpAddr,

    /// UPnP service that generated this event
    pub service: sonos_api::Service,

    /// Source of this event (UPnP notification, polling, or resync)
    pub event_source: EventSource,

    /// Timestamp when this event was processed
    pub timestamp: SystemTime,

    /// The actual event data
    pub event_data: EventData,
}

impl EnrichedEvent {
    /// Create a new enriched event
    pub fn new(
        registration_id: RegistrationId,
        speaker_ip: IpAddr,
        service: sonos_api::Service,
        event_source: EventSource,
        event_data: EventData,
    ) -> Self {
        Self {
            registration_id,
            speaker_ip,
            service,
            event_source,
            timestamp: SystemTime::now(),
            event_data,
        }
    }

    /// Check if this event came from resync detection
    pub fn is_resync_event(&self) -> bool {
        matches!(self.event_source, EventSource::ResyncDetection { .. })
    }

    /// Get the resync reason if this is a resync event
    pub fn resync_reason(&self) -> Option<ResyncReason> {
        match &self.event_source {
            EventSource::ResyncDetection { reason } => Some(reason.clone()),
            _ => None,
        }
    }
}

/// Source of an event - indicates whether it came from UPnP events, polling, or resync detection
#[derive(Debug, Clone)]
pub enum EventSource {
    /// Event came from a UPnP NOTIFY message
    UPnPNotification {
        /// UPnP subscription ID
        subscription_id: String
    },

    /// Event was generated by polling device state
    PollingDetection {
        /// Current polling interval
        poll_interval: Duration
    },

    /// Event was generated by resync detection due to state drift
    ResyncDetection {
        /// Reason for the resync
        reason: ResyncReason
    },
}

/// Reason why a resync event was generated
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ResyncReason {
    /// No events were received for too long
    EventTimeoutDetected,

    /// Polling found different state than expected
    PollingDiscrepancy,

    /// Subscription was renewed, state may have drifted
    SubscriptionRenewal,

    /// Firewall blocking was detected proactively
    FirewallBlocked,

    /// Network connectivity issues detected
    NetworkIssues,

    /// Initial state query (first time registering)
    InitialState,

    /// Manual resync requested (future feature)
    ExplicitRefresh,
}

impl std::fmt::Display for ResyncReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ResyncReason::EventTimeoutDetected => write!(f, "event timeout detected"),
            ResyncReason::PollingDiscrepancy => write!(f, "polling discrepancy"),
            ResyncReason::SubscriptionRenewal => write!(f, "subscription renewal"),
            ResyncReason::FirewallBlocked => write!(f, "firewall blocked"),
            ResyncReason::NetworkIssues => write!(f, "network issues"),
            ResyncReason::InitialState => write!(f, "initial state"),
            ResyncReason::ExplicitRefresh => write!(f, "explicit refresh"),
        }
    }
}

/// Event data - complete event information for each service
#[derive(Debug, Clone)]
pub enum EventData {
    /// AVTransport service event with complete transport state
    AVTransportEvent(AVTransportEvent),

    /// RenderingControl service event with complete rendering state
    RenderingControlEvent(RenderingControlEvent),

    /// DeviceProperties service event with complete device properties
    DevicePropertiesEvent(DevicePropertiesEvent),

    /// ZoneGroupTopology service event with complete topology data
    ZoneGroupTopologyEvent(ZoneGroupTopologyEvent),
}

impl EventData {
    /// Get the service type for this event data
    pub fn service_type(&self) -> sonos_api::Service {
        match self {
            EventData::AVTransportEvent(_) => {
                sonos_api::Service::AVTransport
            }
            EventData::RenderingControlEvent(_) => {
                sonos_api::Service::RenderingControl
            }
            EventData::DevicePropertiesEvent(_) => {
                // DeviceProperties service doesn't exist in sonos-api, using ZoneGroupTopology as fallback
                sonos_api::Service::ZoneGroupTopology
            }
            EventData::ZoneGroupTopologyEvent(_) => {
                sonos_api::Service::ZoneGroupTopology
            }
        }
    }
}

// AVTransport event types

/// Complete AVTransport event data containing all transport state information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AVTransportEvent {
    /// Current transport state (PLAYING, PAUSED_PLAYBACK, STOPPED, etc.)
    pub transport_state: Option<String>,

    /// Current transport status (OK, ERROR_OCCURRED, etc.)
    pub transport_status: Option<String>,

    /// Current playback speed
    pub speed: Option<String>,

    /// Current track URI
    pub current_track_uri: Option<String>,

    /// Track duration
    pub track_duration: Option<String>,

    /// Relative time position in current track
    pub rel_time: Option<String>,

    /// Absolute time position
    pub abs_time: Option<String>,

    /// Relative track number in queue
    pub rel_count: Option<u32>,

    /// Absolute track number
    pub abs_count: Option<u32>,

    /// Current play mode (NORMAL, REPEAT_ALL, REPEAT_ONE, SHUFFLE, etc.)
    pub play_mode: Option<String>,

    /// Current track metadata (DIDL-Lite XML)
    pub track_metadata: Option<String>,

    /// Next track URI
    pub next_track_uri: Option<String>,

    /// Next track metadata
    pub next_track_metadata: Option<String>,

    /// Queue size/length
    pub queue_length: Option<u32>,
}

// RenderingControl event types

/// Complete RenderingControl event data containing all rendering state information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RenderingControlEvent {
    /// Current volume level (0-100) for Master channel
    pub master_volume: Option<String>,

    /// Current volume level (0-100) for Left Front channel
    pub lf_volume: Option<String>,

    /// Current volume level (0-100) for Right Front channel
    pub rf_volume: Option<String>,

    /// Current mute state for Master channel
    pub master_mute: Option<String>,

    /// Current mute state for Left Front channel
    pub lf_mute: Option<String>,

    /// Current mute state for Right Front channel
    pub rf_mute: Option<String>,

    /// Current bass level
    pub bass: Option<String>,

    /// Current treble level
    pub treble: Option<String>,

    /// Current loudness setting
    pub loudness: Option<String>,

    /// Balance setting (-100 to +100)
    pub balance: Option<String>,

    /// Additional channel configurations (can be extended)
    pub other_channels: std::collections::HashMap<String, String>,
}

// DeviceProperties event types

/// Complete DeviceProperties event data containing all device property information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DevicePropertiesEvent {
    /// Current zone name
    pub zone_name: Option<String>,

    /// Current zone icon
    pub zone_icon: Option<String>,

    /// Current configuration information
    pub configuration: Option<String>,

    /// Device capabilities
    pub capabilities: Option<String>,

    /// Firmware version
    pub software_version: Option<String>,

    /// Device model information
    pub model_name: Option<String>,

    /// Device display version
    pub display_version: Option<String>,

    /// Device hardware version
    pub hardware_version: Option<String>,

    /// Additional device properties (extensible)
    pub additional_properties: std::collections::HashMap<String, String>,
}

// ZoneGroupTopology event types

/// Event data for ZoneGroupTopology service containing complete topology information.
/// This passes through the entire parsed topology state without any delta processing.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZoneGroupTopologyEvent {
    /// Complete zone group topology data
    pub zone_groups: Vec<ZoneGroupInfo>,

    /// Devices that have vanished from the network
    pub vanished_devices: Vec<String>, // Can be expanded later if needed
}

/// Information about a single zone group.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZoneGroupInfo {
    /// The coordinator (master) speaker UUID for this group
    pub coordinator: String,

    /// Unique identifier for this zone group
    pub id: String,

    /// All speakers that are members of this zone group
    pub members: Vec<ZoneGroupMemberInfo>,
}

/// Information about a speaker in a zone group.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZoneGroupMemberInfo {
    /// Unique identifier for this speaker (RINCON_...)
    pub uuid: String,

    /// Network location URL of the speaker
    pub location: String,

    /// Human-readable name of the room/zone
    pub zone_name: String,

    /// Software version running on the speaker
    pub software_version: String,

    /// Network configuration (WiFi, ethernet, etc.)
    pub network_info: NetworkInfo,

    /// Satellite speakers for home theater configurations
    pub satellites: Vec<SatelliteInfo>,

    /// Additional metadata (can be extended as needed)
    pub metadata: std::collections::HashMap<String, String>,
}

/// Network configuration information for a speaker.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkInfo {
    /// Wireless mode (0=wired, 1=2.4GHz, 2=5GHz)
    pub wireless_mode: String,

    /// Whether WiFi is enabled
    pub wifi_enabled: String,

    /// Ethernet link status
    pub eth_link: String,

    /// WiFi channel frequency
    pub channel_freq: String,

    /// Whether behind a WiFi extender
    pub behind_wifi_extender: String,
}

/// Information about a satellite speaker.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SatelliteInfo {
    /// Unique identifier for this satellite speaker
    pub uuid: String,

    /// Network location of the satellite
    pub location: String,

    /// Zone name (usually same as main speaker)
    pub zone_name: String,

    /// Home theater satellite channel mapping
    pub ht_sat_chan_map_set: String,

    /// Whether this satellite is invisible in UI
    pub invisible: String,
}

/// A resync event with additional context
#[derive(Debug, Clone)]
pub struct ResyncEvent {
    /// Reason for the resync
    pub reason: ResyncReason,

    /// Complete current state
    pub full_state: EventData,

    /// Previous state (if known)
    pub previous_state: Option<EventData>,

    /// Time when resync was detected
    pub detected_at: SystemTime,
}

impl ResyncEvent {
    /// Create a new resync event
    pub fn new(reason: ResyncReason, full_state: EventData) -> Self {
        Self {
            reason,
            full_state,
            previous_state: None,
            detected_at: SystemTime::now(),
        }
    }

    /// Create a resync event with previous state context
    pub fn with_previous_state(
        reason: ResyncReason,
        full_state: EventData,
        previous_state: EventData,
    ) -> Self {
        Self {
            reason,
            full_state,
            previous_state: Some(previous_state),
            detected_at: SystemTime::now(),
        }
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_enriched_event_creation() {
        let reg_id = RegistrationId::new(1);
        let ip: IpAddr = "192.168.1.100".parse().unwrap();
        let service = sonos_api::Service::AVTransport;
        let source = EventSource::UPnPNotification {
            subscription_id: "uuid:123".to_string(),
        };
        let data = EventData::AVTransportChange(AVTransportDelta::transport_state_change(
            "PLAYING".to_string(),
        ));

        let event = EnrichedEvent::new(reg_id, ip, service, source, data);

        assert_eq!(event.registration_id, reg_id);
        assert_eq!(event.speaker_ip, ip);
        assert_eq!(event.service, service);
        assert!(!event.is_resync_event());
        assert!(event.resync_reason().is_none());
    }

    #[test]
    fn test_resync_event() {
        let reg_id = RegistrationId::new(1);
        let ip: IpAddr = "192.168.1.100".parse().unwrap();
        let service = sonos_api::Service::AVTransport;
        let source = EventSource::ResyncDetection {
            reason: ResyncReason::FirewallBlocked,
        };
        let data = EventData::AVTransportResync(AVTransportFullState {
            transport_state: "PLAYING".to_string(),
            current_track_uri: None,
            track_duration: None,
            rel_time: None,
            play_mode: None,
            track_metadata: None,
            queue_length: None,
            track_number: None,
        });

        let event = EnrichedEvent::new(reg_id, ip, service, source, data);

        assert!(event.is_resync_event());
        assert_eq!(event.resync_reason(), Some(ResyncReason::FirewallBlocked));
    }

    #[test]
    fn test_event_data_service_type() {
        let av_change = EventData::AVTransportChange(AVTransportDelta::transport_state_change(
            "PLAYING".to_string(),
        ));
        assert_eq!(av_change.service_type(), sonos_api::Service::AVTransport);
        assert!(av_change.is_change_event());
        assert!(!av_change.is_resync_event());

        let rc_resync = EventData::RenderingControlResync(RenderingControlFullState {
            volume: "50".to_string(),
            mute: Some(false),
            bass: None,
            treble: None,
            loudness: None,
            balance: None,
        });
        assert_eq!(rc_resync.service_type(), sonos_api::Service::RenderingControl);
        assert!(!rc_resync.is_change_event());
        assert!(rc_resync.is_resync_event());
    }

    #[test]
    fn test_delta_has_changes() {
        let empty_delta = AVTransportDelta {
            transport_state: None,
            current_track_uri: None,
            track_duration: None,
            rel_time: None,
            play_mode: None,
            track_metadata: None,
        };
        assert!(!empty_delta.has_changes());

        let change_delta = AVTransportDelta::transport_state_change("PAUSED".to_string());
        assert!(change_delta.has_changes());

        let rc_delta = RenderingControlDelta::volume_change(75);
        assert!(rc_delta.has_changes());
    }

    #[test]
    fn test_resync_reason_display() {
        assert_eq!(ResyncReason::FirewallBlocked.to_string(), "firewall blocked");
        assert_eq!(ResyncReason::EventTimeoutDetected.to_string(), "event timeout detected");
        assert_eq!(ResyncReason::PollingDiscrepancy.to_string(), "polling discrepancy");
    }

    #[test]
    fn test_resync_event_creation() {
        let full_state = EventData::AVTransportResync(AVTransportFullState {
            transport_state: "PLAYING".to_string(),
            current_track_uri: None,
            track_duration: None,
            rel_time: None,
            play_mode: None,
            track_metadata: None,
            queue_length: None,
            track_number: None,
        });

        let resync_event = ResyncEvent::new(ResyncReason::NetworkIssues, full_state);
        assert_eq!(resync_event.reason, ResyncReason::NetworkIssues);
        assert!(resync_event.previous_state.is_none());
    }
}