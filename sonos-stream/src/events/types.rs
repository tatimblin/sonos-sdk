//! Event types for the sonos-stream crate
//!
//! This module defines all event types used in the streaming system,
//! including events from both UPnP notifications and polling.

use std::net::IpAddr;
use std::time::{Duration, SystemTime};
use serde::{Deserialize, Serialize};

use crate::registry::RegistrationId;

/// An enriched event that includes context and source information
#[derive(Debug, Clone)]
pub struct EnrichedEvent {
    /// Registration ID this event belongs to
    pub registration_id: RegistrationId,

    /// IP address of the speaker that generated this event
    pub speaker_ip: IpAddr,

    /// UPnP service that generated this event
    pub service: sonos_api::Service,

    /// Source of this event (UPnP notification or polling)
    pub event_source: EventSource,

    /// Timestamp when this event was processed
    pub timestamp: SystemTime,

    /// The actual event data
    pub event_data: EventData,
}

impl EnrichedEvent {
    /// Create a new enriched event
    pub fn new(
        registration_id: RegistrationId,
        speaker_ip: IpAddr,
        service: sonos_api::Service,
        event_source: EventSource,
        event_data: EventData,
    ) -> Self {
        Self {
            registration_id,
            speaker_ip,
            service,
            event_source,
            timestamp: SystemTime::now(),
            event_data,
        }
    }

}

/// Source of an event - indicates whether it came from UPnP events or polling
#[derive(Debug, Clone)]
pub enum EventSource {
    /// Event came from a UPnP NOTIFY message
    UPnPNotification {
        /// UPnP subscription ID
        subscription_id: String
    },

    /// Event was generated by polling device state
    PollingDetection {
        /// Current polling interval
        poll_interval: Duration
    },

}


/// Event data - complete event information for each service
#[derive(Debug, Clone)]
pub enum EventData {
    /// AVTransport service event with complete transport state
    AVTransportEvent(AVTransportEvent),

    /// RenderingControl service event with complete rendering state
    RenderingControlEvent(RenderingControlEvent),

    /// DeviceProperties service event with complete device properties
    DevicePropertiesEvent(DevicePropertiesEvent),

    /// ZoneGroupTopology service event with complete topology data
    ZoneGroupTopologyEvent(ZoneGroupTopologyEvent),
}

impl EventData {
    /// Get the service type for this event data
    pub fn service_type(&self) -> sonos_api::Service {
        match self {
            EventData::AVTransportEvent(_) => {
                sonos_api::Service::AVTransport
            }
            EventData::RenderingControlEvent(_) => {
                sonos_api::Service::RenderingControl
            }
            EventData::DevicePropertiesEvent(_) => {
                // DeviceProperties service doesn't exist in sonos-api, using ZoneGroupTopology as fallback
                sonos_api::Service::ZoneGroupTopology
            }
            EventData::ZoneGroupTopologyEvent(_) => {
                sonos_api::Service::ZoneGroupTopology
            }
        }
    }
}

// AVTransport event types

/// Complete AVTransport event data containing all transport state information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AVTransportEvent {
    /// Current transport state (PLAYING, PAUSED_PLAYBACK, STOPPED, etc.)
    pub transport_state: Option<String>,

    /// Current transport status (OK, ERROR_OCCURRED, etc.)
    pub transport_status: Option<String>,

    /// Current playback speed
    pub speed: Option<String>,

    /// Current track URI
    pub current_track_uri: Option<String>,

    /// Track duration
    pub track_duration: Option<String>,

    /// Relative time position in current track
    pub rel_time: Option<String>,

    /// Absolute time position
    pub abs_time: Option<String>,

    /// Relative track number in queue
    pub rel_count: Option<u32>,

    /// Absolute track number
    pub abs_count: Option<u32>,

    /// Current play mode (NORMAL, REPEAT_ALL, REPEAT_ONE, SHUFFLE, etc.)
    pub play_mode: Option<String>,

    /// Current track metadata (DIDL-Lite XML)
    pub track_metadata: Option<String>,

    /// Next track URI
    pub next_track_uri: Option<String>,

    /// Next track metadata
    pub next_track_metadata: Option<String>,

    /// Queue size/length
    pub queue_length: Option<u32>,
}

// RenderingControl event types

/// Complete RenderingControl event data containing all rendering state information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RenderingControlEvent {
    /// Current volume level (0-100) for Master channel
    pub master_volume: Option<String>,

    /// Current volume level (0-100) for Left Front channel
    pub lf_volume: Option<String>,

    /// Current volume level (0-100) for Right Front channel
    pub rf_volume: Option<String>,

    /// Current mute state for Master channel
    pub master_mute: Option<String>,

    /// Current mute state for Left Front channel
    pub lf_mute: Option<String>,

    /// Current mute state for Right Front channel
    pub rf_mute: Option<String>,

    /// Current bass level
    pub bass: Option<String>,

    /// Current treble level
    pub treble: Option<String>,

    /// Current loudness setting
    pub loudness: Option<String>,

    /// Balance setting (-100 to +100)
    pub balance: Option<String>,

    /// Additional channel configurations (can be extended)
    pub other_channels: std::collections::HashMap<String, String>,
}

// DeviceProperties event types

/// Complete DeviceProperties event data containing all device property information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DevicePropertiesEvent {
    /// Current zone name
    pub zone_name: Option<String>,

    /// Current zone icon
    pub zone_icon: Option<String>,

    /// Current configuration information
    pub configuration: Option<String>,

    /// Device capabilities
    pub capabilities: Option<String>,

    /// Firmware version
    pub software_version: Option<String>,

    /// Device model information
    pub model_name: Option<String>,

    /// Device display version
    pub display_version: Option<String>,

    /// Device hardware version
    pub hardware_version: Option<String>,

    /// Additional device properties (extensible)
    pub additional_properties: std::collections::HashMap<String, String>,
}

// ZoneGroupTopology event types

/// Event data for ZoneGroupTopology service containing complete topology information.
/// This passes through the entire parsed topology state without any delta processing.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZoneGroupTopologyEvent {
    /// Complete zone group topology data
    pub zone_groups: Vec<ZoneGroupInfo>,

    /// Devices that have vanished from the network
    pub vanished_devices: Vec<String>, // Can be expanded later if needed
}

/// Information about a single zone group.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZoneGroupInfo {
    /// The coordinator (master) speaker UUID for this group
    pub coordinator: String,

    /// Unique identifier for this zone group
    pub id: String,

    /// All speakers that are members of this zone group
    pub members: Vec<ZoneGroupMemberInfo>,
}

/// Information about a speaker in a zone group.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZoneGroupMemberInfo {
    /// Unique identifier for this speaker (RINCON_...)
    pub uuid: String,

    /// Network location URL of the speaker
    pub location: String,

    /// Human-readable name of the room/zone
    pub zone_name: String,

    /// Software version running on the speaker
    pub software_version: String,

    /// Network configuration (WiFi, ethernet, etc.)
    pub network_info: NetworkInfo,

    /// Satellite speakers for home theater configurations
    pub satellites: Vec<SatelliteInfo>,

    /// Additional metadata (can be extended as needed)
    pub metadata: std::collections::HashMap<String, String>,
}

/// Network configuration information for a speaker.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkInfo {
    /// Wireless mode (0=wired, 1=2.4GHz, 2=5GHz)
    pub wireless_mode: String,

    /// Whether WiFi is enabled
    pub wifi_enabled: String,

    /// Ethernet link status
    pub eth_link: String,

    /// WiFi channel frequency
    pub channel_freq: String,

    /// Whether behind a WiFi extender
    pub behind_wifi_extender: String,
}

/// Information about a satellite speaker.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SatelliteInfo {
    /// Unique identifier for this satellite speaker
    pub uuid: String,

    /// Network location of the satellite
    pub location: String,

    /// Zone name (usually same as main speaker)
    pub zone_name: String,

    /// Home theater satellite channel mapping
    pub ht_sat_chan_map_set: String,

    /// Whether this satellite is invisible in UI
    pub invisible: String,
}



#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_enriched_event_creation() {
        let reg_id = RegistrationId::new(1);
        let ip: IpAddr = "192.168.1.100".parse().unwrap();
        let service = sonos_api::Service::AVTransport;
        let source = EventSource::UPnPNotification {
            subscription_id: "uuid:123".to_string(),
        };
        let data = EventData::AVTransportEvent(AVTransportEvent {
            transport_state: Some("PLAYING".to_string()),
            transport_status: None,
            speed: None,
            current_track_uri: None,
            track_duration: None,
            rel_time: None,
            abs_time: None,
            rel_count: None,
            abs_count: None,
            play_mode: None,
            track_metadata: None,
            next_track_uri: None,
            next_track_metadata: None,
            queue_length: None,
        });

        let event = EnrichedEvent::new(reg_id, ip, service, source, data);

        assert_eq!(event.registration_id, reg_id);
        assert_eq!(event.speaker_ip, ip);
        assert_eq!(event.service, service);
    }


    #[test]
    fn test_event_data_service_type() {
        let av_event = EventData::AVTransportEvent(AVTransportEvent {
            transport_state: Some("PLAYING".to_string()),
            transport_status: None,
            speed: None,
            current_track_uri: None,
            track_duration: None,
            rel_time: None,
            abs_time: None,
            rel_count: None,
            abs_count: None,
            play_mode: None,
            track_metadata: None,
            next_track_uri: None,
            next_track_metadata: None,
            queue_length: None,
        });
        assert_eq!(av_event.service_type(), sonos_api::Service::AVTransport);

        let rc_event = EventData::RenderingControlEvent(RenderingControlEvent {
            master_volume: Some("50".to_string()),
            lf_volume: None,
            rf_volume: None,
            master_mute: Some("false".to_string()),
            lf_mute: None,
            rf_mute: None,
            bass: None,
            treble: None,
            loudness: None,
            balance: None,
            other_channels: std::collections::HashMap::new(),
        });
        assert_eq!(rc_event.service_type(), sonos_api::Service::RenderingControl);
    }

}